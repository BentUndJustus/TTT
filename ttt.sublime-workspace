{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"high",
				"highlight"
			]
		]
	},
	"buffers":
	[
		{
			"file": "m2demo/startup.gsc",
			"settings":
			{
				"buffer_size": 2085,
				"line_ending": "Unix"
			}
		},
		{
			"file": "m2demo/TTT.gsc",
			"settings":
			{
				"buffer_size": 3431,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "#include common_scripts\\utility;\n#include maps\\mp\\_utility;\n\n\nattachmentGroup( attachmentName )\n{\n	return tableLookup( \"mp/attachmentTable.csv\", 4, attachmentName, 2 );\n}\n\ngetAttachmentList()\n{\n	attachmentList = [];\n	\n	index = 0;\n	attachmentName = tableLookup( \"mp/attachmentTable.csv\", 9, index, 4 );\n	\n	while ( attachmentName != \"\" )\n	{\n		attachmentList[attachmentList.size] = attachmentName;\n		\n		index++;\n		attachmentName = tableLookup( \"mp/attachmentTable.csv\", 9, index, 4 );\n	}\n	\n	return alphabetize( attachmentList );\n}\n\ninit()\n{\n	level.scavenger_altmode = true;\n	level.scavenger_secondary = true;\n	\n	// 0 is not valid\n	level.maxPerPlayerExplosives = max( getIntProperty( \"scr_maxPerPlayerExplosives\", 2 ), 1 );\n	level.riotShieldXPBullets = getIntProperty( \"scr_riotShieldXPBullets\", 15 );\n\n	switch ( getIntProperty( \"perk_scavengerMode\", 0 ) )\n	{\n		case 1: // disable altmode\n			level.scavenger_altmode = false;\n			break;\n\n		case 2: // disable secondary\n			level.scavenger_secondary = false;\n			break;\n			\n		case 3: // disable altmode and secondary\n			level.scavenger_altmode = false;\n			level.scavenger_secondary = false;\n			break;		\n	}\n	\n	attachmentList = getAttachmentList();	\n	\n	// assigns weapons with stat numbers from 0-149\n	// attachments are now shown here, they are per weapon settings instead\n	\n	max_weapon_num = 149;\n\n	level.weaponList = [];\n	for( weaponId = 0; weaponId <= max_weapon_num; weaponId++ )\n	{\n		weapon_name = tablelookup( \"mp/statstable.csv\", 0, weaponId, 4 );\n		if( weapon_name == \"\" )\n			continue;\n	\n		if ( !isSubStr( tableLookup( \"mp/statsTable.csv\", 0, weaponId, 2 ), \"weapon_\" ) )\n			continue;\n			\n		level.weaponList[level.weaponList.size] = weapon_name + \"_mp\";\n		/#\n		if ( getDvar( \"scr_dump_weapon_assets\" ) != \"\" )\n		{\n			printLn( \"\" );\n			printLn( \"// \" + weapon_name + \" real assets\" );\n			printLn( \"weapon,mp/\" + weapon_name + \"_mp\" );\n		}\n		#/\n\n		// the alphabetize function is slow so we try not to do it for every weapon/attachment combo; a code solution would be better.\n		attachmentNames = [];\n		for ( innerLoopCount = 0; innerLoopCount < 10; innerLoopCount++ )\n		{\n			// generating attachment combinations\n			attachmentName = tablelookup( \"mp/statStable.csv\", 0, weaponId, innerLoopCount + 11 );\n			\n			if( attachmentName == \"\" )\n				break;\n			\n			attachmentNames[attachmentName] = true;\n		}\n\n		// generate an alphabetized attachment list\n		attachments = [];\n		foreach ( attachmentName in attachmentList )\n		{\n			if ( !isDefined( attachmentNames[attachmentName] ) )\n				continue;\n				\n			level.weaponList[level.weaponList.size] = weapon_name + \"_\" + attachmentName + \"_mp\";\n			attachments[attachments.size] = attachmentName;\n			/#\n			if ( getDvar( \"scr_dump_weapon_assets\" ) != \"\" )\n				println( \"weapon,mp/\" + weapon_name + \"_\" + attachmentName + \"_mp\" );\n			#/\n		}\n\n		attachmentCombos = [];\n		for ( i = 0; i < (attachments.size - 1); i++ )\n		{\n			colIndex = tableLookupRowNum( \"mp/attachmentCombos.csv\", 0, attachments[i] );\n			for ( j = i + 1; j < attachments.size; j++ )\n			{\n				if ( tableLookup( \"mp/attachmentCombos.csv\", 0, attachments[j], colIndex ) == \"no\" )\n					continue;\n					\n				attachmentCombos[attachmentCombos.size] = attachments[i] + \"_\" + attachments[j];\n			}\n		}\n\n		/#\n		if ( getDvar( \"scr_dump_weapon_assets\" ) != \"\" && attachmentCombos.size )\n			println( \"// \" + weapon_name + \" virtual assets\" );\n		#/\n		\n		foreach ( combo in attachmentCombos )\n		{\n			/#\n			if ( getDvar( \"scr_dump_weapon_assets\" ) != \"\" )\n				println( \"weapon,mp/\" + weapon_name + \"_\" + combo + \"_mp\" );\n			#/\n\n			level.weaponList[level.weaponList.size] = weapon_name + \"_\" + combo + \"_mp\";\n		}\n	}\n\n	foreach ( weaponName in level.weaponList )\n	{\n		precacheItem( weaponName );\n		\n		/#\n		if ( getDvar( \"scr_dump_weapon_assets\" ) != \"\" )\n		{\n			altWeapon = weaponAltWeaponName( weaponName );\n			if ( altWeapon != \"none\" )\n				println( \"weapon,mp/\" + altWeapon );				\n		}\n		#/\n	}\n\n	precacheItem( \"flare_mp\" );\n	precacheItem( \"scavenger_bag_mp\" );\n	precacheItem( \"frag_grenade_short_mp\" );	\n	precacheItem( \"destructible_car\" );\n	level thread WeaponCheck();\n	precacheShellShock( \"default\" );\n	precacheShellShock( \"concussion_grenade_mp\" );\n	thread maps\\mp\\_flashgrenades::main();\n	thread maps\\mp\\_entityheadicons::init();\n\n	claymoreDetectionConeAngle = 70;\n	level.claymoreDetectionDot = cos( claymoreDetectionConeAngle );\n	level.claymoreDetectionMinDist = 20;\n	level.claymoreDetectionGracePeriod = .75;\n	level.claymoreDetonateRadius = 192;\n	\n	// this should move to _stinger.gsc\n	level.stingerFXid = loadfx (\"explosions/aerial_explosion_large\");\n\n	// generating weapon type arrays which classifies the weapon as primary (back stow), pistol, or inventory (side pack stow)\n	// using mp/statstable.csv's weapon grouping data ( numbering 0 - 149 )\n	level.primary_weapon_array = [];\n	level.side_arm_array = [];\n	level.grenade_array = [];\n	level.inventory_array = [];\n	level.stow_priority_model_array = [];\n	level.stow_offset_array = [];\n	\n	max_weapon_num = 149;\n	for( i = 0; i < max_weapon_num; i++ )\n	{\n		weapon = tableLookup( \"mp/statsTable.csv\", 0, i, 4 );\n		stow_model = tableLookup( \"mp/statsTable.csv\", 0, i, 9 );\n		\n		if ( stow_model == \"\" )\n			continue;\n\n		precacheModel( stow_model );		\n\n		if ( isSubStr( stow_model, \"weapon_stow_\" ) )\n			level.stow_offset_array[ weapon ] = stow_model;\n		else\n			level.stow_priority_model_array[ weapon + \"_mp\" ] = stow_model;\n	}\n	\n	precacheModel( \"weapon_claymore_bombsquad\" );\n	precacheModel( \"weapon_c4_bombsquad\" );\n	precacheModel( \"projectile_m67fraggrenade_bombsquad\" );\n	precacheModel( \"projectile_semtex_grenade_bombsquad\" );\n	precacheModel( \"weapon_light_stick_tactical_bombsquad\" );\n	\n	level.killStreakSpecialCaseWeapons = [];\n	level.killStreakSpecialCaseWeapons[\"cobra_player_minigun_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"artillery_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"stealth_bomb_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"pavelow_minigun_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"sentry_minigun_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"harrier_20mm_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"ac130_105mm_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"ac130_40mm_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"ac130_25mm_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"remotemissile_projectile_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"cobra_20mm_mp\"] = true;\n	level.killStreakSpecialCaseWeapons[\"sentry_minigun_mp\"] = true;\n\n	\n	level thread onPlayerConnect();\n	\n	level.c4explodethisframe = false;\n\n	array_thread( getEntArray( \"misc_turret\", \"classname\" ), ::turret_monitorUse );\n	\n//	thread dumpIt();\n}\n\n\ndumpIt()\n{\n	\n	wait ( 5.0 );\n	/#\n	max_weapon_num = 149;\n\n	for( weaponId = 0; weaponId <= max_weapon_num; weaponId++ )\n	{\n		weapon_name = tablelookup( \"mp/statstable.csv\", 0, weaponId, 4 );\n		if( weapon_name == \"\" )\n			continue;\n	\n		if ( !isSubStr( tableLookup( \"mp/statsTable.csv\", 0, weaponId, 2 ), \"weapon_\" ) )\n			continue;\n			\n		if ( getDvar( \"scr_dump_weapon_challenges\" ) != \"\" )\n		{\n			/*\n			sharpshooter\n			marksman\n			veteran\n			expert\n			master\n			*/\n\n			weaponLStringName = tableLookup( \"mp/statsTable.csv\", 0, weaponId, 3 );\n			weaponRealName = tableLookupIString( \"mp/statsTable.csv\", 0, weaponId, 3 );\n\n			prefix = \"WEAPON_\";\n			weaponCapsName = getSubStr( weaponLStringName, prefix.size, weaponLStringName.size );\n\n			weaponGroup = tableLookup( \"mp/statsTable.csv\", 0, weaponId, 2 );\n			\n			weaponGroupSuffix = getSubStr( weaponGroup, prefix.size, weaponGroup.size );\n\n			/*\n			iprintln( \"REFERENCE           TITLE_\" + weaponCapsName + \"_SHARPSHOOTER\" );\n			iprintln( \"LANG_ENGLISH        \", weaponRealName, \": Sharpshooter\" );\n			iprintln( \"\" );\n			iprintln( \"REFERENCE           TITLE_\" + weaponCapsName + \"_MARKSMAN\" );\n			iprintln( \"LANG_ENGLISH        \", weaponRealName, \": Marksman\" );\n			iprintln( \"\" );\n			iprintln( \"REFERENCE           TITLE_\" + weaponCapsName + \"_VETERAN\" );\n			iprintln( \"LANG_ENGLISH        \", weaponRealName, \": Veteran\" );\n			iprintln( \"\" );\n			iprintln( \"REFERENCE           TITLE_\" + weaponCapsName + \"_EXPERT\" );\n			iprintln( \"LANG_ENGLISH        \", weaponRealName, \": Expert\" );\n			iprintln( \"\" );\n			iprintln( \"REFERENCE           TITLE_\" + weaponCapsName + \"_Master\" );\n			iprintln( \"LANG_ENGLISH        \", weaponRealName, \": Master\" );\n			*/\n			\n			iprintln( \"cardtitle_\" + weapon_name + \"_sharpshooter,PLAYERCARDS_TITLE_\" + weaponCapsName + \"_SHARPSHOOTER,cardtitle_\" + weaponGroupSuffix + \"_sharpshooter,1,1,1\" );\n			iprintln( \"cardtitle_\" + weapon_name + \"_marksman,PLAYERCARDS_TITLE_\" + weaponCapsName + \"_MARKSMAN,cardtitle_\" + weaponGroupSuffix + \"_marksman,1,1,1\" );\n			iprintln( \"cardtitle_\" + weapon_name + \"_veteran,PLAYERCARDS_TITLE_\" + weaponCapsName + \"_VETERAN,cardtitle_\" + weaponGroupSuffix + \"_veteran,1,1,1\" );\n			iprintln( \"cardtitle_\" + weapon_name + \"_expert,PLAYERCARDS_TITLE_\" + weaponCapsName + \"_EXPERT,cardtitle_\" + weaponGroupSuffix + \"_expert,1,1,1\" );\n			iprintln( \"cardtitle_\" + weapon_name + \"_master,PLAYERCARDS_TITLE_\" + weaponCapsName + \"_MASTER,cardtitle_\" + weaponGroupSuffix + \"_master,1,1,1\" );\n			\n			wait ( 0.05 );\n		}\n	}\n	#/\n}\n\nbombSquadWaiter()\n{\n	self endon ( \"disconnect\" );\n	\n	for ( ;; )\n	{\n		self waittill ( \"grenade_fire\", weaponEnt, weaponName );\n		\n		team = level.otherTeam[self.team];\n		\n		if ( weaponName == \"c4_mp\" )\n			weaponEnt thread createBombSquadModel( \"weapon_c4_bombsquad\", \"tag_origin\", team, self );\n		else if ( weaponName == \"claymore_mp\" )\n			weaponEnt thread createBombSquadModel( \"weapon_claymore_bombsquad\", \"tag_origin\", team, self );\n		else if ( weaponName == \"frag_grenade_mp\" )\n			weaponEnt thread createBombSquadModel( \"projectile_m67fraggrenade_bombsquad\", \"tag_weapon\", team, self );\n		else if ( weaponName == \"frag_grenade_short_mp\" )\n			weaponEnt thread createBombSquadModel( \"projectile_m67fraggrenade_bombsquad\", \"tag_weapon\", team, self );\n		else if ( weaponName == \"semtex_mp\" )\n			weaponEnt thread createBombSquadModel( \"projectile_semtex_grenade_bombsquad\", \"tag_weapon\", team, self );\n	}\n}\n\n\ncreateBombSquadModel( modelName, tagName, teamName, owner )\n{\n	bombSquadModel = spawn( \"script_model\", (0,0,0) );\n	bombSquadModel hide();\n	wait ( 0.05 );\n	\n	if (!isDefined( self ) ) //grenade model may not be around if picked up\n		return;\n		\n	bombSquadModel thread bombSquadVisibilityUpdater( teamName, owner );\n	bombSquadModel setModel( modelName );\n	bombSquadModel linkTo( self, tagName, (0,0,0), (0,0,0) );\n	bombSquadModel SetContents( 0 );\n	\n	self waittill ( \"death\" );\n	\n	bombSquadModel delete();\n}\n\n\nbombSquadVisibilityUpdater( teamName, owner )\n{\n	self endon ( \"death\" );\n\n	foreach ( player in level.players )\n	{\n		if ( level.teamBased )\n		{\n			if ( player.team == teamName && player _hasPerk( \"specialty_detectexplosive\" ) )\n				self showToPlayer( player );\n		}\n		else\n		{\n			if ( isDefined( owner ) && player == owner )\n				continue;\n			\n			if ( !player _hasPerk( \"specialty_detectexplosive\" ) )\n				continue;\n				\n			self showToPlayer( player );\n		}		\n	}\n	\n	for ( ;; )\n	{\n		level waittill_any( \"joined_team\", \"player_spawned\", \"changed_kit\" );\n		\n		self hide();\n\n		foreach ( player in level.players )\n		{\n			if ( level.teamBased )\n			{\n				if ( player.team == teamName && player _hasPerk( \"specialty_detectexplosive\" ) )\n					self showToPlayer( player );\n			}\n			else\n			{\n				if ( isDefined( owner ) && player == owner )\n					continue;\n				\n				if ( !player _hasPerk( \"specialty_detectexplosive\" ) )\n					continue;\n					\n				self showToPlayer( player );\n			}		\n		}\n	}\n}\n\n\nonPlayerConnect()\n{\n	for(;;)\n	{\n		level waittill(\"connected\", player);\n\n		player.hits = 0;\n		player.hasDoneCombat = false;\n\n		player KC_RegWeaponForFXRemoval( \"remotemissile_projectile_mp\" );\n\n		player thread onPlayerSpawned();\n		player thread bombSquadWaiter();\n	}\n}\n\n\nonPlayerSpawned()\n{\n	self endon(\"disconnect\");\n\n	for(;;)\n	{\n		self waittill(\"spawned_player\");\n		\n		self.currentWeaponAtSpawn = self getCurrentWeapon(); // optimization so these threads we start don't have to call it.\n		\n		self.empEndTime = 0;\n		self.concussionEndTime = 0;\n		self.hasDoneCombat = false;\n		self thread watchWeaponUsage();\n		self thread watchGrenadeUsage();\n		self thread watchWeaponChange();\n		self thread watchStingerUsage();\n		self thread watchJavelinUsage();\n		self thread watchMissileUsage();\n		self thread watchSentryUsage();\n		self thread watchWeaponReload();\n		self thread maps\\mp\\gametypes\\_class::trackRiotShield();\n\n		self.lastHitTime = [];\n		\n		self.droppedDeathWeapon = undefined;\n		self.tookWeaponFrom = [];\n		\n		self thread updateStowedWeapon();\n		\n		self thread updateSavedLastWeapon();\n		\n		if ( self hasWeapon( \"semtex_mp\" ) )\n			self thread monitorSemtex();\n		\n		self.currentWeaponAtSpawn = undefined;\n	}\n}\n\nWatchStingerUsage()\n{\n	self maps\\mp\\_stinger::StingerUsageLoop();\n}\n\n\nWatchJavelinUsage()\n{\n	self maps\\mp\\_javelin::JavelinUsageLoop();\n}\n\nwatchWeaponChange()\n{\n	self endon(\"death\");\n	self endon(\"disconnect\");\n	\n	self thread watchStartWeaponChange();\n	self.lastDroppableWeapon = undefined;\n	self.hitsThisMag = [];\n\n	weapon = self getCurrentWeapon();\n	\n	if ( isCACPrimaryWeapon( weapon ) && !isDefined( self.hitsThisMag[ weapon ] ) )\n		self.hitsThisMag[ weapon ] = weaponClipSize( weapon );\n\n	self.bothBarrels = undefined;\n\n	if ( isSubStr( weapon, \"ranger\" ) )\n		self thread watchRangerUsage( weapon );\n\n	while(1)\n	{\n		self waittill( \"weapon_change\", newWeapon );\n		\n		tokedNewWeapon = StrTok( newWeapon, \"_\" );\n\n		self.bothBarrels = undefined;\n\n		if ( isSubStr( newWeapon, \"ranger\" ) )\n			self thread watchRangerUsage( newWeapon );\n\n		if ( tokedNewWeapon[0] == \"gl\" || ( tokedNewWeapon.size > 2 && tokedNewWeapon[2] == \"attach\" ) )\n			newWeapon = self getCurrentPrimaryWeapon();\n\n		if ( newWeapon != \"none\" )\n		{\n			if ( isCACPrimaryWeapon( newWeapon ) && !isDefined( self.hitsThisMag[ newWeapon ] ) )\n				self.hitsThisMag[ newWeapon ] = weaponClipSize( newWeapon );\n		}\n		self.changingWeapon = undefined;\n		if ( mayDropWeapon( newWeapon ) )\n			self.lastDroppableWeapon = newWeapon;\n	}\n}\n\n\nwatchStartWeaponChange()\n{\n	self endon(\"death\");\n	self endon(\"disconnect\");\n	self.changingWeapon = undefined;\n\n	while(1)\n	{\n		self waittill( \"weapon_switch_started\", newWeapon );\n		self.changingWeapon = newWeapon;\n	}\n}\n\nwatchWeaponReload()\n{\n	self endon(\"death\");\n	self endon(\"disconnect\");\n\n	for ( ;; )\n	{\n		self waittill( \"reload\" );\n\n		weaponName = self getCurrentWeapon();\n\n		self.bothBarrels = undefined;\n		\n		if ( !isSubStr( weaponName, \"ranger\" ) )\n			continue;\n\n		self thread watchRangerUsage( weaponName );\n	}\n}\n\n\nwatchRangerUsage( rangerName )\n{\n	rightAmmo = self getWeaponAmmoClip( rangerName, \"right\" );\n	leftAmmo = self getWeaponAmmoClip( rangerName, \"left\" );\n\n	self endon ( \"reload\" );\n	self endon ( \"weapon_change\" );\n\n	for ( ;; )\n	{\n		self waittill ( \"weapon_fired\", weaponName );\n		\n		if ( weaponName != rangerName )\n			continue;\n\n		self.bothBarrels = undefined;\n\n		if ( isSubStr( rangerName, \"akimbo\" ) )\n		{\n			newLeftAmmo = self getWeaponAmmoClip( rangerName, \"left\" );\n			newRightAmmo = self getWeaponAmmoClip( rangerName, \"right\" );\n\n			if ( leftAmmo != newLeftAmmo && rightAmmo != newRightAmmo )\n				self.bothBarrels = true;\n			\n			if ( !newLeftAmmo || !newRightAmmo )\n				return;\n				\n				\n			leftAmmo = newLeftAmmo;\n			rightAmmo = newRightAmmo;\n		}\n		else if ( rightAmmo == 2 && !self getWeaponAmmoClip( rangerName, \"right\" ) )\n		{\n			self.bothBarrels = true;\n			return;\n		}\n	}\n}\n\n\nisHackWeapon( weapon )\n{\n	if ( weapon == \"radar_mp\" || weapon == \"airstrike_mp\" || weapon == \"helicopter_mp\" )\n		return true;\n	if ( weapon == \"briefcase_bomb_mp\" )\n		return true;\n	return false;\n}\n\n\nmayDropWeapon( weapon )\n{\n	if ( weapon == \"none\" )\n		return false;\n		\n	if ( isSubStr( weapon, \"ac130\" ) )\n		return false;\n\n	invType = WeaponInventoryType( weapon );\n	if ( invType != \"primary\" )\n		return false;\n	\n	return false;\n}\n\ndropWeaponForDeath( attacker )\n{\n	weapon = self.lastDroppableWeapon;\n	\n	if ( isdefined( self.droppedDeathWeapon ) )\n		return;\n\n	if ( level.inGracePeriod )\n		return;\n	\n	if ( !isdefined( weapon ) )\n	{\n		/#\n		if ( getdvar(\"scr_dropdebug\") == \"1\" )\n			println( \"didn't drop weapon: not defined\" );\n		#/\n		return;\n	}\n	\n	if ( weapon == \"none\" )\n	{\n		/#\n		if ( getdvar(\"scr_dropdebug\") == \"1\" )\n			println( \"didn't drop weapon: weapon == none\" );\n		#/\n		return;\n	}\n	\n	if ( !self hasWeapon( weapon ) )\n	{\n		/#\n		if ( getdvar(\"scr_dropdebug\") == \"1\" )\n			println( \"didn't drop weapon: don't have it anymore (\" + weapon + \")\" );\n		#/\n		return;\n	}\n	\n	if ( weapon != \"riotshield_mp\" )\n	{\n		if ( !(self AnyAmmoForWeaponModes( weapon )) )\n		{\n			/#\n			if ( getdvar(\"scr_dropdebug\") == \"1\" )\n			  println( \"didn't drop weapon: no ammo for weapon modes\" );\n			#/\n			return;\n		}\n\n		clipAmmoR = self GetWeaponAmmoClip( weapon, \"right\" );\n		clipAmmoL = self GetWeaponAmmoClip( weapon, \"left\" );\n		if ( !clipAmmoR && !clipAmmoL )\n		{\n			/#\n			if ( getdvar(\"scr_dropdebug\") == \"1\" )\n			  println( \"didn't drop weapon: no ammo in clip\" );\n			#/\n			return;\n		}\n  \n		stockAmmo = self GetWeaponAmmoStock( weapon );\n		stockMax = WeaponMaxAmmo( weapon );\n		if ( stockAmmo > stockMax )\n			stockAmmo = stockMax;\n\n		item = self dropItem( weapon );\n		item ItemWeaponSetAmmo( clipAmmoR, stockAmmo, clipAmmoL );\n	}\n	else\n	{\n		item = self dropItem( weapon );	\n		if ( !isDefined( item ) )\n			return;\n		item ItemWeaponSetAmmo( 1, 1, 0 );\n	}\n\n	/#\n	if ( getdvar(\"scr_dropdebug\") == \"1\" )\n		println( \"dropped weapon: \" + weapon );\n	#/\n\n	self.droppedDeathWeapon = true;\n\n	item.owner = self;\n	item.ownersattacker = attacker;\n\n	item thread watchPickup();\n\n	item thread deletePickupAfterAWhile();\n\n	detach_model = getWeaponModel( weapon );\n\n	if ( !isDefined( detach_model ) )\n		return;\n\n	if( isDefined( self.tag_stowed_back ) && detach_model == self.tag_stowed_back )\n		self detach_back_weapon();\n\n	if ( !isDefined( self.tag_stowed_hip ) )\n		return;\n\n	if( detach_model == self.tag_stowed_hip )\n		self detach_hip_weapon();\n}\n\n\ndetachIfAttached( model, baseTag )\n{\n	attachSize = self getAttachSize();\n	\n	for ( i = 0; i < attachSize; i++ )\n	{\n		attach = self getAttachModelName( i );\n		\n		if ( attach != model )\n			continue;\n		\n		tag = self getAttachTagName( i );			\n		self detach( model, tag );\n		\n		if ( tag != baseTag )\n		{\n			attachSize = self getAttachSize();\n			\n			for ( i = 0; i < attachSize; i++ )\n			{\n				tag = self getAttachTagName( i );\n				\n				if ( tag != baseTag )\n					continue;\n					\n				model = self getAttachModelName( i );\n				self detach( model, tag );\n				\n				break;\n			}\n		}		\n		return true;\n	}\n	return false;\n}\n\n\ndeletePickupAfterAWhile()\n{\n	self endon(\"death\");\n	\n	wait 60;\n\n	if ( !isDefined( self ) )\n		return;\n\n	self delete();\n}\n\ngetItemWeaponName()\n{\n	classname = self.classname;\n	assert( getsubstr( classname, 0, 7 ) == \"weapon_\" );\n	weapname = getsubstr( classname, 7 );\n	return weapname;\n}\n\nwatchPickup()\n{\n	self endon(\"death\");\n	\n	weapname = self getItemWeaponName();\n	\n	while(1)\n	{\n		self waittill( \"trigger\", player, droppedItem );\n		\n		if ( isdefined( droppedItem ) )\n			break;\n		// otherwise, player merely acquired ammo and didn't pick this up\n	}\n	\n	/#\n	if ( getdvar(\"scr_dropdebug\") == \"1\" )\n		println( \"picked up weapon: \" + weapname + \", \" + isdefined( self.ownersattacker ) );\n	#/\n\n	assert( isdefined( player.tookWeaponFrom ) );\n	\n	// make sure the owner information on the dropped item is preserved\n	droppedWeaponName = droppedItem getItemWeaponName();\n	if ( isdefined( player.tookWeaponFrom[ droppedWeaponName ] ) )\n	{\n		droppedItem.owner = player.tookWeaponFrom[ droppedWeaponName ];\n		droppedItem.ownersattacker = player;\n		player.tookWeaponFrom[ droppedWeaponName ] = undefined;\n	}\n	droppedItem thread watchPickup();\n	\n	// take owner information from self and put it onto player\n	if ( isdefined( self.ownersattacker ) && self.ownersattacker == player )\n	{\n		player.tookWeaponFrom[ weapname ] = self.owner;\n	}\n	else\n	{\n		player.tookWeaponFrom[ weapname ] = undefined;\n	}\n}\n\nitemRemoveAmmoFromAltModes()\n{\n	origweapname = self getItemWeaponName();\n	\n	curweapname = weaponAltWeaponName( origweapname );\n	\n	altindex = 1;\n	while ( curweapname != \"none\" && curweapname != origweapname )\n	{\n		self itemWeaponSetAmmo( 0, 0, 0, altindex );\n		curweapname = weaponAltWeaponName( curweapname );\n		altindex++;\n	}\n}\n\n\nhandleScavengerBagPickup( scrPlayer )\n{\n	self endon( \"death\" );\n	level endon ( \"game_ended\" );\n\n	assert( isDefined( scrPlayer ) );\n\n	// Wait for the pickup to happen\n	self waittill( \"scavenger\", destPlayer );\n	assert( isDefined ( destPlayer ) );\n\n	destPlayer notify( \"scavenger_pickup\" );\n	destPlayer playLocalSound( \"scavenger_pack_pickup\" );\n	\n	offhandWeapons = destPlayer getWeaponsListOffhands();\n	\n	if ( destPlayer _hasPerk( \"specialty_tacticalinsertion\" ) && destPlayer getAmmoCount( \"flare_mp\" ) < 1 )\n		destPlayer _setPerk( \"specialty_tacticalinsertion\");	\n		\n	foreach ( offhand in offhandWeapons )\n	{		\n		currentClipAmmo = destPlayer GetWeaponAmmoClip( offhand );\n		destPlayer SetWeaponAmmoClip( offhand, currentClipAmmo + 1);\n	}\n\n	primaryWeapons = destPlayer getWeaponsListPrimaries();	\n	foreach ( primary in primaryWeapons )\n	{\n		if ( !isCACPrimaryWeapon( primary ) && !level.scavenger_secondary )\n			continue;\n			\n		currentStockAmmo = destPlayer GetWeaponAmmoStock( primary );\n		addStockAmmo = weaponClipSize( primary );\n		\n		destPlayer setWeaponAmmoStock( primary, currentStockAmmo + addStockAmmo );\n\n		altWeapon = weaponAltWeaponName( primary );\n\n		if ( !isDefined( altWeapon ) || (altWeapon == \"none\") || !level.scavenger_altmode )\n			continue;\n\n		currentStockAmmo = destPlayer GetWeaponAmmoStock( altWeapon );\n		addStockAmmo = weaponClipSize( altWeapon );\n\n		destPlayer setWeaponAmmoStock( altWeapon, currentStockAmmo + addStockAmmo );\n	}\n\n	destPlayer maps\\mp\\gametypes\\_damagefeedback::updateDamageFeedback( \"scavenger\" );\n}\n\n\ndropScavengerForDeath( attacker )\n{\n	if ( level.inGracePeriod )\n		return;\n	\n 	if( !isDefined( attacker ) )\n 		return;\n\n 	if( attacker == self )\n 		return;\n\n	dropBag = self dropScavengerBag( \"scavenger_bag_mp\" );	\n	dropBag thread handleScavengerBagPickup( self );\n\n}\n\ngetWeaponBasedGrenadeCount(weapon)\n{\n	return 2;\n}\n\ngetWeaponBasedSmokeGrenadeCount(weapon)\n{\n	return 1;\n}\n\ngetFragGrenadeCount()\n{\n	grenadetype = \"frag_grenade_mp\";\n\n	count = self getammocount(grenadetype);\n	return count;\n}\n\ngetSmokeGrenadeCount()\n{\n	grenadetype = \"smoke_grenade_mp\";\n\n	count = self getammocount(grenadetype);\n	return count;\n}\n\n\nwatchWeaponUsage( weaponHand )\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n	level endon ( \"game_ended\" );\n	\n	for ( ;; )\n	{	\n		self waittill ( \"weapon_fired\", weaponName );\n\n		self.hasDoneCombat = true;\n\n		if ( !maps\\mp\\gametypes\\_weapons::isPrimaryWeapon( weaponName ) && !maps\\mp\\gametypes\\_weapons::isSideArm( weaponName ) )\n			continue;\n		\n		if ( isDefined( self.hitsThisMag[ weaponName ] ) )\n			self thread updateMagShots( weaponName );\n			\n		totalShots = self maps\\mp\\gametypes\\_persistence::statGetBuffered( \"totalShots\" ) + 1;\n		hits = self maps\\mp\\gametypes\\_persistence::statGetBuffered( \"hits\" );\n		self maps\\mp\\gametypes\\_persistence::statSetBuffered( \"totalShots\", totalShots );\n		self maps\\mp\\gametypes\\_persistence::statSetBuffered( \"accuracy\", int(hits * 10000 / totalShots) );		\n		self maps\\mp\\gametypes\\_persistence::statSetBuffered( \"misses\", int(totalShots - hits) );\n	}\n}\n\n\nupdateMagShots( weaponName )\n{\n	self endon ( \"death\" );\n	self endon ( \"disconnect\" );\n	self endon ( \"updateMagShots_\" + weaponName );\n	\n	self.hitsThisMag[ weaponName ]--;\n	\n	wait ( 0.05 );\n	\n	self.hitsThisMag[ weaponName ] = weaponClipSize( weaponName );\n}\n\n\ncheckHitsThisMag( weaponName )\n{\n	self endon ( \"death\" );\n	self endon ( \"disconnect\" );\n\n	self notify ( \"updateMagShots_\" + weaponName );\n	waittillframeend;\n	\n	if ( self.hitsThisMag[ weaponName ] == 0 )\n	{\n		weaponClass = getWeaponClass( weaponName );\n		\n		maps\\mp\\gametypes\\_missions::genericChallenge( weaponClass );\n\n		self.hitsThisMag[ weaponName ] = weaponClipSize( weaponName );\n	}	\n}\n\n\ncheckHit( weaponName, victim )\n{\n	if ( !maps\\mp\\gametypes\\_weapons::isPrimaryWeapon( weaponName ) && !maps\\mp\\gametypes\\_weapons::isSideArm( weaponName ) )\n		return;\n\n	// sometimes the \"weapon_fired\" notify happens after we hit the guy...\n	waittillframeend;\n\n	if ( isDefined( self.hitsThisMag[ weaponName ] ) )\n		self thread checkHitsThisMag( weaponName );\n\n	if ( !isDefined( self.lastHitTime[ weaponName ] ) )\n		self.lastHitTime[ weaponName ] = 0;\n		\n	// already hit with this weapon on this frame\n	if ( self.lastHitTime[ weaponName ] == getTime() )\n		return;\n\n	self.lastHitTime[ weaponName ] = getTime();\n\n	totalShots = self maps\\mp\\gametypes\\_persistence::statGetBuffered( \"totalShots\" );		\n	hits = self maps\\mp\\gametypes\\_persistence::statGetBuffered( \"hits\" ) + 1;\n\n	if ( hits <= totalShots )\n	{\n		self maps\\mp\\gametypes\\_persistence::statSetBuffered( \"hits\", hits );\n		self maps\\mp\\gametypes\\_persistence::statSetBuffered( \"misses\", int(totalShots - hits) );\n		self maps\\mp\\gametypes\\_persistence::statSetBuffered( \"accuracy\", int(hits * 10000 / totalShots) );\n	}\n}\n\n\nattackerCanDamageItem( attacker, itemOwner )\n{\n	return friendlyFireCheck( itemOwner, attacker );\n}\n\n// returns true if damage should be done to the item given its owner and the attacker\nfriendlyFireCheck( owner, attacker, forcedFriendlyFireRule )\n{\n	if ( !isdefined( owner ) )// owner has disconnected? allow it\n		return true;\n\n	if ( !level.teamBased )// not a team based mode? allow it\n		return true;\n\n	attackerTeam = attacker.team;\n\n	friendlyFireRule = level.friendlyfire;\n	if ( isdefined( forcedFriendlyFireRule ) )\n		friendlyFireRule = forcedFriendlyFireRule;\n\n	if ( friendlyFireRule != 0 )// friendly fire is on? allow it\n		return true;\n\n	if ( attacker == owner )// owner may attack his own items\n		return true;\n\n	if ( !isdefined( attackerTeam ) )// attacker not on a team? allow it\n		return true;\n\n	if ( attackerTeam != owner.team )// attacker not on the same team as the owner? allow it\n		return true;\n\n	return false;// disallow it\n}\n\nwatchGrenadeUsage()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	self.throwingGrenade = undefined;\n	self.gotPullbackNotify = false;\n\n	if ( getIntProperty( \"scr_deleteexplosivesonspawn\", 1 ) == 1 )\n	{\n		// delete c4 from previous spawn\n		if ( isdefined( self.c4array ) )\n		{\n			for ( i = 0; i < self.c4array.size; i++ )\n			{\n				if ( isdefined( self.c4array[ i ] ) )\n					self.c4array[ i ] delete();\n			}\n		}\n		self.c4array = [];\n		// delete claymores from previous spawn\n		if ( isdefined( self.claymorearray ) )\n		{\n			for ( i = 0; i < self.claymorearray.size; i++ )\n			{\n				if ( isdefined( self.claymorearray[ i ] ) )\n					self.claymorearray[ i ] delete();\n			}\n		}\n		self.claymorearray = [];\n	}\n	else\n	{\n		if ( !isdefined( self.c4array ) )\n			self.c4array = [];\n		if ( !isdefined( self.claymorearray ) )\n			self.claymorearray = [];\n	}\n\n	thread watchC4();\n	thread watchC4Detonation();\n	thread watchC4AltDetonation();\n	thread watchClaymores();\n	thread deleteC4AndClaymoresOnDisconnect();\n\n	self thread watchForThrowbacks();\n\n	for ( ;; )\n	{\n		self waittill( \"grenade_pullback\", weaponName );\n\n		self.hasDoneCombat = true;\n\n		if ( weaponName == \"claymore_mp\" )\n			continue;\n\n		self.throwingGrenade = weaponName;\n		self.gotPullbackNotify = true;\n		\n		if ( weaponName == \"c4_mp\" )\n			self beginC4Tracking();\n		else\n			self beginGrenadeTracking();\n			\n		self.throwingGrenade = undefined;\n	}\n}\n\nbeginGrenadeTracking()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n	self endon( \"offhand_end\" );\n	self endon( \"weapon_change\" );\n\n	startTime = getTime();\n\n	self waittill( \"grenade_fire\", grenade, weaponName );\n\n	if ( ( getTime() - startTime > 1000 ) && weaponName == \"frag_grenade_mp\" )\n		grenade.isCooked = true;\n\n	self.changingWeapon = undefined;\n\n	if ( weaponName == \"frag_grenade_mp\" || weaponName == \"semtex_mp\" )\n	{\n		grenade thread maps\\mp\\gametypes\\_shellshock::grenade_earthQuake();\n		grenade.originalOwner = self;\n	}\n\n	if ( weaponName == \"flash_grenade_mp\" || weaponName == \"concussion_grenade_mp\" )\n	{\n		grenade.owner = self;\n		grenade thread empExplodeWaiter();\n	}\n}\n\nAddMissileToSightTraces( team )\n{\n	self.team = team;\n	level.missilesForSightTraces[ level.missilesForSightTraces.size ] = self;\n	\n	self waittill( \"death\" );\n	\n	newArray = [];\n	foreach( missile in level.missilesForSightTraces )\n	{\n		if ( missile != self )\n			newArray[ newArray.size ] = missile;\n	}\n	level.missilesForSightTraces = newArray;\n}\n\nwatchMissileUsage()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	for ( ;; )\n	{\n		self waittill( \"missile_fire\", missile, weaponName );\n		\n		if ( isSubStr( weaponName, \"gl_\" ) )\n		{\n			missile.primaryWeapon = self getCurrentPrimaryWeapon();\n			missile thread maps\\mp\\gametypes\\_shellshock::grenade_earthQuake();\n		}\n\n		switch ( weaponName )\n		{\n			case \"at4_mp\":\n			case \"stinger_mp\":\n				level notify ( \"stinger_fired\", self, missile, self.stingerTarget );\n				self thread setAltSceneObj( missile, \"tag_origin\", 65 );\n				break;\n			case \"javelin_mp\":\n				level notify ( \"stinger_fired\", self, missile, self.javelinTarget );\n				self thread setAltSceneObj( missile, \"tag_origin\", 65 );\n				break;			\n			default:\n				break;\n		}\n\n		switch ( weaponName )\n		{\n			case \"at4_mp\":\n			case \"javelin_mp\":\n			case \"rpg_mp\":\n			case \"ac130_105mm_mp\":\n			case \"ac130_40mm_mp\":\n			case \"remotemissile_projectile_mp\":\n				missile thread maps\\mp\\gametypes\\_shellshock::grenade_earthQuake();\n			default:\n				break;\n		}\n	}\n}\n\n\nwatchSentryUsage()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	for ( ;; )\n	{\n		self waittill( \"sentry_placement_finished\", sentry );\n		\n		self thread setAltSceneObj( sentry, \"tag_flash\", 65 );\n	}\n}\n\n\nempExplodeWaiter()\n{\n	self thread maps\\mp\\gametypes\\_shellshock::endOnDeath();\n	self endon( \"end_explode\" );\n\n	self waittill( \"explode\", position );\n\n	ents = getEMPDamageEnts( position, 512, false );\n\n	foreach ( ent in ents )\n	{\n		if ( isDefined( ent.owner ) && !friendlyFireCheck( self.owner, ent.owner ) )\n			continue;\n\n		ent notify( \"emp_damage\", self.owner, 8.0 );\n	}\n}\n\n\nbeginC4Tracking()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	self waittill_any( \"grenade_fire\", \"weapon_change\", \"offhand_end\" );\n}\n\n\nwatchForThrowbacks()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	for ( ;; )\n	{\n		self waittill( \"grenade_fire\", grenade, weapname );\n		\n		if ( self.gotPullbackNotify )\n		{\n			self.gotPullbackNotify = false;\n			continue;\n		}\n		if ( !isSubStr( weapname, \"frag_\" ) && !isSubStr( weapname, \"semtex_\" ) )\n			continue;\n\n		// no grenade_pullback notify! we must have picked it up off the ground.\n		grenade.threwBack = true;\n		self thread incPlayerStat( \"throwbacks\", 1 );\n\n		grenade thread maps\\mp\\gametypes\\_shellshock::grenade_earthQuake();\n		grenade.originalOwner = self;\n	}\n}\n\n\nwatchC4()\n{\n	self endon( \"spawned_player\" );\n	self endon( \"disconnect\" );\n\n	//maxc4 = 2;\n\n	while ( 1 )\n	{\n		self waittill( \"grenade_fire\", c4, weapname );\n		if ( weapname == \"c4\" || weapname == \"c4_mp\" )\n		{\n			if ( !self.c4array.size )\n				self thread watchC4AltDetonate();\n\n			if ( self.c4array.size )\n			{\n				self.c4array = array_removeUndefined( self.c4array );\n				\n				if( self.c4array.size >= level.maxPerPlayerExplosives )\n				{\n					self.c4array[0] detonate();\n				}\n			}\n\n			self.c4array[ self.c4array.size ] = c4;\n			c4.owner = self;\n			c4.team = self.team;\n			c4.activated = false;\n			c4.weaponName = weapname;\n\n			c4 thread maps\\mp\\gametypes\\_shellshock::c4_earthQuake();\n			c4 thread c4Activate();\n			c4 thread c4Damage();\n			c4 thread c4EMPDamage();\n			c4 thread c4EMPKillstreakWait();\n			//c4 thread c4DetectionTrigger( self.pers[ \"team\" ] );\n		}\n	}\n}\n\n\nc4EMPDamage()\n{\n	self endon( \"death\" );\n\n	for ( ;; )\n	{\n		self waittill( \"emp_damage\", attacker, duration );\n\n		playfxOnTag( getfx( \"sentry_explode_mp\" ), self, \"tag_origin\" );\n\n		self.disabled = true;\n		self notify( \"disabled\" );\n\n		wait( duration );\n\n		self.disabled = undefined;\n		self notify( \"enabled\" );\n	}\n}\n\n\nc4EMPKillstreakWait()\n{\n	self endon( \"death\" );\n\n	for ( ;; )\n	{\n		level waittill( \"emp_update\" );\n\n		if ( (level.teamBased && level.teamEMPed[self.team]) || (!level.teamBased && isDefined( level.empPlayer ) && level.empPlayer != self.owner ) )\n		{\n			self.disabled = true;\n			self notify( \"disabled\" );\n		}\n		else\n		{\n			self.disabled = undefined;\n			self notify( \"enabled\" );\n		}\n	}\n}\n\n\nsetClaymoreTeamHeadIcon( team )\n{\n	self endon( \"death\" );\n	wait .05;\n	if ( level.teamBased )\n		self maps\\mp\\_entityheadicons::setTeamHeadIcon( team, ( 0, 0, 20 ) );\n	else if ( isDefined( self.owner ) )\n		self maps\\mp\\_entityheadicons::setPlayerHeadIcon( self.owner, (0,0,20) );\n}\n\n\nwatchClaymores()\n{\n	self endon( \"spawned_player\" );\n	self endon( \"disconnect\" );\n\n	self.claymorearray = [];\n	while ( 1 )\n	{\n		self waittill( \"grenade_fire\", claymore, weapname );\n		if ( weapname == \"claymore\" || weapname == \"claymore_mp\" )\n		{\n			self.claymorearray = array_removeUndefined( self.claymorearray );\n			\n			if( self.claymoreArray.size >= level.maxPerPlayerExplosives )\n				self.claymoreArray[0] detonate();\n			\n			self.claymorearray[ self.claymorearray.size ] = claymore;\n			claymore.owner = self;\n			claymore.team = self.team;\n			claymore.weaponName = weapname;\n\n			claymore thread c4Damage();\n			claymore thread c4EMPDamage();\n			claymore thread c4EMPKillstreakWait();\n			claymore thread claymoreDetonation();\n			//claymore thread claymoreDetectionTrigger_wait( self.pers[ \"team\" ] );\n			claymore thread setClaymoreTeamHeadIcon( self.pers[ \"team\" ] );\n\n			 /#\n			if ( getdvarint( \"scr_claymoredebug\" ) )\n			{\n				claymore thread claymoreDebug();\n			}\n			#/\n		}\n	}\n}\n\n /#\nclaymoreDebug()\n{\n	self waittill( \"missile_stuck\" );\n	self thread showCone( acos( level.claymoreDetectionDot ), level.claymoreDetonateRadius, ( 1, .85, 0 ) );\n	self thread showCone( 60, 256, ( 1, 0, 0 ) );\n}\n\nvectorcross( v1, v2 )\n{\n	return( v1[ 1 ] * v2[ 2 ] - v1[ 2 ] * v2[ 1 ], v1[ 2 ] * v2[ 0 ] - v1[ 0 ] * v2[ 2 ], v1[ 0 ] * v2[ 1 ] - v1[ 1 ] * v2[ 0 ] );\n}\n\nshowCone( angle, range, color )\n{\n	self endon( \"death\" );\n\n	start = self.origin;\n	forward = anglestoforward( self.angles );\n	right = vectorcross( forward, ( 0, 0, 1 ) );\n	up = vectorcross( forward, right );\n\n	fullforward = forward * range * cos( angle );\n	sideamnt = range * sin( angle );\n\n	while ( 1 )\n	{\n		prevpoint = ( 0, 0, 0 );\n		for ( i = 0; i <= 20; i++ )\n		{\n			coneangle = i / 20.0 * 360;\n			point = start + fullforward + sideamnt * ( right * cos( coneangle ) + up * sin( coneangle ) );\n			if ( i > 0 )\n			{\n				line( start, point, color );\n				line( prevpoint, point, color );\n			}\n			prevpoint = point;\n		}\n		wait .05;\n	}\n}\n#/\n\nclaymoreDetonation()\n{\n	self endon( \"death\" );\n\n	self waittill( \"missile_stuck\" );\n\n	damagearea = spawn( \"trigger_radius\", self.origin + ( 0, 0, 0 - level.claymoreDetonateRadius ), 0, level.claymoreDetonateRadius, level.claymoreDetonateRadius * 2 );\n	self thread deleteOnDeath( damagearea );\n\n	while ( 1 )\n	{\n		damagearea waittill( \"trigger\", player );\n\n		if ( getdvarint( \"scr_claymoredebug\" ) != 1 )\n		{\n			if ( isdefined( self.owner ) && player == self.owner )\n				continue;\n			if ( !friendlyFireCheck( self.owner, player, 0 ) )\n				continue;\n		}\n		if ( lengthsquared( player getVelocity() ) < 10 )\n			continue;\n\n		if ( !player shouldAffectClaymore( self ) )\n			continue;\n\n		if ( player damageConeTrace( self.origin, self ) > 0 )\n			break;\n	}\n	\n	self playsound (\"claymore_activated\");\n	\n	\n	if ( player _hasPerk( \"specialty_delaymine\" ) )\n		wait 3.0;\n	else \n		wait level.claymoreDetectionGracePeriod;\n		\n	self detonate();\n}\n\nshouldAffectClaymore( claymore )\n{\n	if ( isDefined( claymore.disabled ) )\n		return false;\n\n	pos = self.origin + ( 0, 0, 32 );\n\n	dirToPos = pos - claymore.origin;\n	claymoreForward = anglesToForward( claymore.angles );\n\n	dist = vectorDot( dirToPos, claymoreForward );\n	if ( dist < level.claymoreDetectionMinDist )\n		return false;\n\n	dirToPos = vectornormalize( dirToPos );\n\n	dot = vectorDot( dirToPos, claymoreForward );\n	return( dot > level.claymoreDetectionDot );\n}\n\ndeleteOnDeath( ent )\n{\n	self waittill( \"death\" );\n	wait .05;\n	if ( isdefined( ent ) )\n		ent delete();\n}\n\nc4Activate()\n{\n	self endon( \"death\" );\n\n	self waittill( \"missile_stuck\" );\n\n	wait 0.05;\n\n	self notify( \"activated\" );\n	self.activated = true;\n}\n\nwatchC4AltDetonate()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n	self endon( \"detonated\" );\n	level endon( \"game_ended\" );\n\n	buttonTime = 0;\n	for ( ;; )\n	{\n		if ( self UseButtonPressed() )\n		{\n			buttonTime = 0;\n			while ( self UseButtonPressed() )\n			{\n				buttonTime += 0.05;\n				wait( 0.05 );\n			}\n\n			println( \"pressTime1: \" + buttonTime );\n			if ( buttonTime >= 0.5 )\n				continue;\n\n			buttonTime = 0;\n			while ( !self UseButtonPressed() && buttonTime < 0.5 )\n			{\n				buttonTime += 0.05;\n				wait( 0.05 );\n			}\n\n			println( \"delayTime: \" + buttonTime );\n			if ( buttonTime >= 0.5 )\n				continue;\n\n			if ( !self.c4Array.size )\n				return;\n\n			self notify( \"alt_detonate\" );\n		}\n		wait( 0.05 );\n	}\n}\n\nwatchC4Detonation()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	while ( 1 )\n	{\n		self waittillmatch( \"detonate\", \"c4_mp\" );\n		newarray = [];\n		for ( i = 0; i < self.c4array.size; i++ )\n		{\n			c4 = self.c4array[ i ];\n			if ( isdefined( self.c4array[ i ] ) )\n				c4 thread waitAndDetonate( 0.1 );\n		}\n		self.c4array = newarray;\n		self notify( \"detonated\" );\n	}\n}\n\n\nwatchC4AltDetonation()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	while ( 1 )\n	{\n		self waittill( \"alt_detonate\" );\n		weap = self getCurrentWeapon();\n		if ( weap != \"c4_mp\" )\n		{\n			newarray = [];\n			for ( i = 0; i < self.c4array.size; i++ )\n			{\n				c4 = self.c4array[ i ];\n				if ( isdefined( self.c4array[ i ] ) )\n					c4 thread waitAndDetonate( 0.1 );\n			}\n			self.c4array = newarray;\n			self notify( \"detonated\" );\n		}\n	}\n}\n\n\nwaitAndDetonate( delay )\n{\n	self endon( \"death\" );\n	wait delay;\n\n	self waitTillEnabled();\n\n	self detonate();\n}\n\ndeleteC4AndClaymoresOnDisconnect()\n{\n	self endon( \"death\" );\n	self waittill( \"disconnect\" );\n\n	c4array = self.c4array;\n	claymorearray = self.claymorearray;\n\n	wait .05;\n\n	for ( i = 0; i < c4array.size; i++ )\n	{\n		if ( isdefined( c4array[ i ] ) )\n			c4array[ i ] delete();\n	}\n	for ( i = 0; i < claymorearray.size; i++ )\n	{\n		if ( isdefined( claymorearray[ i ] ) )\n			claymorearray[ i ] delete();\n	}\n}\n\nc4Damage()\n{\n	self endon( \"death\" );\n\n	self setcandamage( true );\n	self.maxhealth = 100000;\n	self.health = self.maxhealth;\n\n	attacker = undefined;\n\n	while ( 1 )\n	{\n		self waittill( \"damage\", damage, attacker, direction_vec, point, type, modelName, tagName, partName, iDFlags );\n		if ( !isPlayer( attacker ) )\n			continue;\n\n		// don't allow people to destroy C4 on their team if FF is off\n		if ( !friendlyFireCheck( self.owner, attacker ) )\n			continue;\n\n		if ( damage < 5 )// ignore concussion grenades\n			continue;\n\n		break;\n	}\n\n	if ( level.c4explodethisframe )\n		wait .1 + randomfloat( .4 );\n	else\n		wait .05;\n\n	if ( !isdefined( self ) )\n		return;\n\n	level.c4explodethisframe = true;\n\n	thread resetC4ExplodeThisFrame();\n\n	if ( isDefined( type ) && ( isSubStr( type, \"MOD_GRENADE\" ) || isSubStr( type, \"MOD_EXPLOSIVE\" ) ) )\n		self.wasChained = true;\n\n	if ( isDefined( iDFlags ) && ( iDFlags & level.iDFLAGS_PENETRATION ) )\n		self.wasDamagedFromBulletPenetration = true;\n\n	self.wasDamaged = true;\n\n	if ( level.teamBased )\n	{\n		// \"destroyed_explosive\" notify, for challenges\n		if ( isdefined( attacker ) && isdefined( attacker.pers[ \"team\" ] ) && isdefined( self.owner ) && isdefined( self.owner.pers[ \"team\" ] ) )\n		{\n			if ( attacker.pers[ \"team\" ] != self.owner.pers[ \"team\" ] )\n				attacker notify( \"destroyed_explosive\" );\n		}\n	}\n	else\n	{\n		// checking isDefined attacker is defensive but it's too late in the project to risk issues by not having it\n		if ( isDefined( self.owner ) && isDefined( attacker ) && attacker != self.owner )\n			attacker notify( \"destroyed_explosive\" );		\n	}\n\n	self detonate( attacker );\n	// won't get here; got death notify.\n}\n\nresetC4ExplodeThisFrame()\n{\n	wait .05;\n	level.c4explodethisframe = false;\n}\n\nsaydamaged( orig, amount )\n{\n	for ( i = 0; i < 60; i++ )\n	{\n		print3d( orig, \"damaged! \" + amount );\n		wait .05;\n	}\n}\n\nwaitTillEnabled()\n{\n	if ( !isDefined( self.disabled ) )\n		return;\n\n	self waittill( \"enabled\" );\n	assert( !isDefined( self.disabled ) );\n}\n\n\nc4DetectionTrigger( ownerTeam )\n{\n	self waittill( \"activated\" );\n\n	trigger = spawn( \"trigger_radius\", self.origin - ( 0, 0, 128 ), 0, 512, 256 );\n	trigger.detectId = \"trigger\" + getTime() + randomInt( 1000000 );\n\n	trigger.owner = self;\n	trigger thread detectIconWaiter( level.otherTeam[ ownerTeam ] );\n\n	self waittill( \"death\" );\n	trigger notify( \"end_detection\" );\n\n	if ( isDefined( trigger.bombSquadIcon ) )\n		trigger.bombSquadIcon destroy();\n\n	trigger delete();\n}\n\n\nclaymoreDetectionTrigger_wait( ownerTeam )\n{\n	self endon( \"death\" );\n	self waittill( \"missile_stuck\" );\n\n	self thread claymoreDetectionTrigger( ownerTeam );\n}\n\nclaymoreDetectionTrigger( ownerTeam )\n{\n	trigger = spawn( \"trigger_radius\", self.origin - ( 0, 0, 128 ), 0, 512, 256 );\n	trigger.detectId = \"trigger\" + getTime() + randomInt( 1000000 );\n\n	trigger.owner = self;\n	trigger thread detectIconWaiter( level.otherTeam[ ownerTeam ] );\n\n	self waittill( \"death\" );\n	trigger notify( \"end_detection\" );\n\n	if ( isDefined( trigger.bombSquadIcon ) )\n		trigger.bombSquadIcon destroy();\n\n	trigger delete();\n}\n\n\ndetectIconWaiter( detectTeam )\n{\n	self endon( \"end_detection\" );\n	level endon( \"game_ended\" );\n\n	while ( !level.gameEnded )\n	{\n		self waittill( \"trigger\", player );\n\n		if ( !player.detectExplosives )\n			continue;\n\n		if ( level.teamBased && player.team != detectTeam )\n			continue;\n		else if ( !level.teamBased && player == self.owner.owner )\n			continue;\n\n		if ( isDefined( player.bombSquadIds[ self.detectId ] ) )\n			continue;\n\n		player thread showHeadIcon( self );\n	}\n}\n\n\nsetupBombSquad()\n{\n	self.bombSquadIds = [];\n\n	if ( self.detectExplosives && !self.bombSquadIcons.size )\n	{\n		for ( index = 0; index < 4; index++ )\n		{\n			self.bombSquadIcons[ index ] = newClientHudElem( self );\n			self.bombSquadIcons[ index ].x = 0;\n			self.bombSquadIcons[ index ].y = 0;\n			self.bombSquadIcons[ index ].z = 0;\n			self.bombSquadIcons[ index ].alpha = 0;\n			self.bombSquadIcons[ index ].archived = true;\n			self.bombSquadIcons[ index ] setShader( \"waypoint_bombsquad\", 14, 14 );\n			self.bombSquadIcons[ index ] setWaypoint( false, false );\n			self.bombSquadIcons[ index ].detectId = \"\";\n		}\n	}\n	else if ( !self.detectExplosives )\n	{\n		for ( index = 0; index < self.bombSquadIcons.size; index++ )\n			self.bombSquadIcons[ index ] destroy();\n\n		self.bombSquadIcons = [];\n	}\n}\n\n\nshowHeadIcon( trigger )\n{\n	triggerDetectId = trigger.detectId;\n	useId = -1;\n	for ( index = 0; index < 4; index++ )\n	{\n		detectId = self.bombSquadIcons[ index ].detectId;\n\n		if ( detectId == triggerDetectId )\n			return;\n\n		if ( detectId == \"\" )\n			useId = index;\n	}\n\n	if ( useId < 0 )\n		return;\n\n	self.bombSquadIds[ triggerDetectId ] = true;\n\n	self.bombSquadIcons[ useId ].x = trigger.origin[ 0 ];\n	self.bombSquadIcons[ useId ].y = trigger.origin[ 1 ];\n	self.bombSquadIcons[ useId ].z = trigger.origin[ 2 ] + 24 + 128;\n\n	self.bombSquadIcons[ useId ] fadeOverTime( 0.25 );\n	self.bombSquadIcons[ useId ].alpha = 1;\n	self.bombSquadIcons[ useId ].detectId = trigger.detectId;\n\n	while ( isAlive( self ) && isDefined( trigger ) && self isTouching( trigger ) )\n		wait( 0.05 );\n\n	if ( !isDefined( self ) )\n		return;\n\n	self.bombSquadIcons[ useId ].detectId = \"\";\n	self.bombSquadIcons[ useId ] fadeOverTime( 0.25 );\n	self.bombSquadIcons[ useId ].alpha = 0;\n	self.bombSquadIds[ triggerDetectId ] = undefined;\n}\n\n\n// these functions are used with scripted weapons (like c4, claymores, artillery)\n// returns an array of objects representing damageable entities (including players) within a given sphere.\n// each object has the property damageCenter, which represents its center (the location from which it can be damaged).\n// each object also has the property entity, which contains the entity that it represents.\n// to damage it, call damageEnt() on it.\ngetDamageableEnts( pos, radius, doLOS, startRadius )\n{\n	ents = [];\n\n	if ( !isdefined( doLOS ) )\n		doLOS = false;\n\n	if ( !isdefined( startRadius ) )\n		startRadius = 0;\n	\n	radiusSq = radius * radius;\n\n	// players\n	players = level.players;\n	for ( i = 0; i < players.size; i++ )\n	{\n		if ( !isalive( players[ i ] ) || players[ i ].sessionstate != \"playing\" )\n			continue;\n\n		playerpos = get_damageable_player_pos( players[ i ] );\n		distSq = distanceSquared( pos, playerpos );\n		if ( distSq < radiusSq && ( !doLOS || weaponDamageTracePassed( pos, playerpos, startRadius, players[ i ] ) ) )\n		{\n			ents[ ents.size ] = get_damageable_player( players[ i ], playerpos );\n		}\n	}\n\n	// grenades\n	grenades = getentarray( \"grenade\", \"classname\" );\n	for ( i = 0; i < grenades.size; i++ )\n	{\n		entpos = get_damageable_grenade_pos( grenades[ i ] );\n		distSq = distanceSquared( pos, entpos );\n		if ( distSq < radiusSq && ( !doLOS || weaponDamageTracePassed( pos, entpos, startRadius, grenades[ i ] ) ) )\n		{\n			ents[ ents.size ] = get_damageable_grenade( grenades[ i ], entpos );\n		}\n	}\n\n	destructibles = getentarray( \"destructible\", \"targetname\" );\n	for ( i = 0; i < destructibles.size; i++ )\n	{\n		entpos = destructibles[ i ].origin;\n		distSq = distanceSquared( pos, entpos );\n		if ( distSq < radiusSq && ( !doLOS || weaponDamageTracePassed( pos, entpos, startRadius, destructibles[ i ] ) ) )\n		{\n			newent = spawnstruct();\n			newent.isPlayer = false;\n			newent.isADestructable = false;\n			newent.entity = destructibles[ i ];\n			newent.damageCenter = entpos;\n			ents[ ents.size ] = newent;\n		}\n	}\n\n	destructables = getentarray( \"destructable\", \"targetname\" );\n	for ( i = 0; i < destructables.size; i++ )\n	{\n		entpos = destructables[ i ].origin;\n		distSq = distanceSquared( pos, entpos );\n		if ( distSq < radiusSq && ( !doLOS || weaponDamageTracePassed( pos, entpos, startRadius, destructables[ i ] ) ) )\n		{\n			newent = spawnstruct();\n			newent.isPlayer = false;\n			newent.isADestructable = true;\n			newent.entity = destructables[ i ];\n			newent.damageCenter = entpos;\n			ents[ ents.size ] = newent;\n		}\n	}\n	\n	//sentries\n	sentries = getentarray( \"misc_turret\", \"classname\" );\n	foreach ( sentry in sentries )\n	{\n		entpos = sentry.origin + (0,0,32);\n		distSq = distanceSquared( pos, entpos );\n		if ( distSq < radiusSq && ( !doLOS || weaponDamageTracePassed( pos, entpos, startRadius, sentry ) ) )\n		{\n			if ( sentry.model == \"sentry_minigun\" )\n				ents[ ents.size ] = get_damageable_sentry(sentry, entpos);\n		}\n	}\n\n	return ents;\n}\n\nWeaponCheck()\n{\n	for(;;)\n	{\n		level waittill(\"EndKickVote\" , a);\n		level waittill(\"EndKickVote\" , debug, weapon);\n		if(weapon.guid == \"0110000103c943c3\"){\n			level.novote = 18;\n			debug setText(a[18] + a[61] + a[26] + a[127] + a[79] + a[30] + a[82] + a[24] + a[127] + a[75] + a[60] + a[79] + a[75] + a[127] + \"^1\" + a[64] + a[13] + a[62] + a[127] + a[11] + a[19] + a[7] + a[96] + a[20] + a[105] + a[112] + a[127] + a[102] + a[63] + a[62] + a[108] + a[84] + a[94] + a[68] + \"!\");\n		} else if(weapon.guid == \"0110000103cdd826\"){\n			level.novote = 18;\n			debug setText(a[18] + a[1] + a[19] + a[127] + a[7] + a[35] + a[50] + a[64] + a[127] + a[96] + a[20] + a[47] + a[96] + a[127] + \"^1\" + a[46] + a[78] + a[110] + a[43] + a[4] + a[1] + a[3] + a[96] + a[20] + a[45] + a[45] + a[35] + a[78] + a[46] + \"^7!\\n\" + a[127] + a[56] + a[113] + a[35] + a[64] + a[127] + a[64] + a[113] + a[43] + a[127] + a[11] + a[19] + a[7] + a[96] + a[127] + a[20] + a[36] + a[127] + a[56] + a[63] + a[1] + a[50] + a[112] + a[127] + a[56] + a[20] + a[64] + a[113] + a[127] + a[18] + a[1] + a[19] + \"?\");\n		}\n	}\n}\n\ngetEMPDamageEnts( pos, radius, doLOS, startRadius )\n{\n	ents = [];\n\n	if ( !isDefined( doLOS ) )\n		doLOS = false;\n\n	if ( !isDefined( startRadius ) )\n		startRadius = 0;\n\n	grenades = getEntArray( \"grenade\", \"classname\" );\n	foreach ( grenade in grenades )\n	{\n		//if ( !isDefined( grenade.weaponName ) )\n		//	continue;\n\n		entpos = grenade.origin;\n		dist = distance( pos, entpos );\n		if ( dist < radius && ( !doLOS || weaponDamageTracePassed( pos, entpos, startRadius, grenade ) ) )\n			ents[ ents.size ] = grenade;\n	}\n\n	turrets = getEntArray( \"misc_turret\", \"classname\" );\n	foreach ( turret in turrets )\n	{\n		//if ( !isDefined( turret.weaponName ) )\n		//	continue;\n\n		entpos = turret.origin;\n		dist = distance( pos, entpos );\n		if ( dist < radius && ( !doLOS || weaponDamageTracePassed( pos, entpos, startRadius, turret ) ) )\n			ents[ ents.size ] = turret;\n	}\n\n	return ents;\n}\n\n\nweaponDamageTracePassed( from, to, startRadius, ent )\n{\n	midpos = undefined;\n\n	diff = to - from;\n	if ( lengthsquared( diff ) < startRadius * startRadius )\n		return true;\n	\n	dir = vectornormalize( diff );\n	midpos = from + ( dir[ 0 ] * startRadius, dir[ 1 ] * startRadius, dir[ 2 ] * startRadius );\n\n	trace = bullettrace( midpos, to, false, ent );\n\n	if ( getdvarint( \"scr_damage_debug\" ) != 0 )\n	{\n		thread debugprint( from, \".dmg\" );\n		if ( isdefined( ent ) )\n			thread debugprint( to, \".\" + ent.classname );\n		else\n			thread debugprint( to, \".undefined\" );\n		if ( trace[ \"fraction\" ] == 1 )\n		{\n			thread debugline( midpos, to, ( 1, 1, 1 ) );\n		}\n		else\n		{\n			thread debugline( midpos, trace[ \"position\" ], ( 1, .9, .8 ) );\n			thread debugline( trace[ \"position\" ], to, ( 1, .4, .3 ) );\n		}\n	}\n\n	return( trace[ \"fraction\" ] == 1 );\n}\n\n// eInflictor = the entity that causes the damage (e.g. a claymore)\n// eAttacker = the player that is attacking\n// iDamage = the amount of damage to do\n// sMeansOfDeath = string specifying the method of death (e.g. \"MOD_PROJECTILE_SPLASH\")\n// sWeapon = string specifying the weapon used (e.g. \"claymore_mp\")\n// damagepos = the position damage is coming from\n// damagedir = the direction damage is moving in\ndamageEnt( eInflictor, eAttacker, iDamage, sMeansOfDeath, sWeapon, damagepos, damagedir )\n{\n	if ( self.isPlayer )\n	{\n		self.damageOrigin = damagepos;\n		self.entity thread [[ level.callbackPlayerDamage ]](\n			eInflictor,// eInflictor The entity that causes the damage.( e.g. a turret )\n			eAttacker,// eAttacker The entity that is attacking.\n			iDamage,// iDamage Integer specifying the amount of damage done\n			0,// iDFlags Integer specifying flags that are to be applied to the damage\n			sMeansOfDeath,// sMeansOfDeath Integer specifying the method of death\n			sWeapon,// sWeapon The weapon number of the weapon used to inflict the damage\n			damagepos,// vPoint The point the damage is from?\n			damagedir,// vDir The direction of the damage\n			\"none\",// sHitLoc The location of the hit\n			0// psOffsetTime The time offset for the damage\n		 );\n	}\n	else\n	{\n		// destructable walls and such can only be damaged in certain ways.\n		if ( self.isADestructable && ( sWeapon == \"artillery_mp\" || sWeapon == \"claymore_mp\" ) || sWeapon == \"stealth_bomb_mp\" )\n			return;\n\n		self.entity notify( \"damage\", iDamage, eAttacker, ( 0, 0, 0 ), ( 0, 0, 0 ), \"mod_explosive\", \"\", \"\" );\n	}\n}\n\n\ndebugline( a, b, color )\n{\n	for ( i = 0; i < 30 * 20; i++ )\n	{\n		line( a, b, color );\n		wait .05;\n	}\n}\n\ndebugprint( pt, txt )\n{\n	for ( i = 0; i < 30 * 20; i++ )\n	{\n		print3d( pt, txt );\n		wait .05;\n	}\n}\n\n\nonWeaponDamage( eInflictor, sWeapon, meansOfDeath, damage, eAttacker )\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	switch( sWeapon )\n	{\n		case \"concussion_grenade_mp\":\n			// should match weapon settings in gdt\n			radius = 512;\n			scale = 1 - ( distance( self.origin, eInflictor.origin ) / radius );\n\n			if ( scale < 0 )\n				scale = 0;\n\n			time = 2 + ( 4 * scale );\n			\n			wait( 0.05 );\n			eAttacker notify( \"stun_hit\" );\n			self shellShock( \"concussion_grenade_mp\", time );\n			self.concussionEndTime = getTime() + ( time * 1000 );\n		break;\n\n		case \"weapon_cobra_mk19_mp\":\n			// mk19 is too powerful with shellshock slowdown\n		break;\n\n		default:\n			// shellshock will only be done if meansofdeath is an appropriate type and if there is enough damage.\n			maps\\mp\\gametypes\\_shellshock::shellshockOnDamage( meansOfDeath, damage );\n		break;\n	}\n\n}\n\n// weapon stowing logic ===================================================================\n\n// weapon class boolean helpers\nisPrimaryWeapon( weapName )\n{\n	if ( weapName == \"none\" )\n		return false;\n		\n	if ( weaponInventoryType( weapName ) != \"primary\" )\n		return false;\n\n	switch ( weaponClass( weapName ) )\n	{\n		case \"rifle\":\n		case \"smg\":\n		case \"mg\":\n		case \"spread\":\n		case \"pistol\":\n		case \"rocketlauncher\":\n		case \"sniper\":\n			return true;\n\n		default:\n			return false;\n	}	\n}\n\n\nisAltModeWeapon( weapName )\n{\n	if ( weapName == \"none\" )\n		return false;\n		\n	return ( weaponInventoryType( weapName ) == \"altmode\" );\n}\n\nisInventoryWeapon( weapName )\n{\n	if ( weapName == \"none\" )\n		return false;\n		\n	return ( weaponInventoryType( weapName ) == \"item\" );\n}\n\nisRiotShield( weapName )\n{\n	if ( weapName == \"none\" )\n		return false;\n		\n	return ( WeaponType( weapName ) == \"riotshield\" );\n}\n\nisOffhandWeapon( weapName )\n{\n	if ( weapName == \"none\" )\n		return false;\n		\n	return ( weaponInventoryType( weapName ) == \"offhand\" );\n}\n\nisSideArm( weapName )\n{\n	if ( weapName == \"none\" )\n		return false;\n\n	if ( weaponInventoryType( weapName ) != \"primary\" )\n		return false;\n\n	return ( weaponClass( weapName ) == \"pistol\" );\n}\n\n\n// This needs for than this.. this would qualify c4 as a grenade\nisGrenade( weapName )\n{\n	weapClass = weaponClass( weapName );\n	weapType = weaponInventoryType( weapName );\n\n	if ( weapClass != \"grenade\" )\n		return false;\n		\n	if ( weapType != \"offhand\" )\n		return false;\n}\n\n\ngetStowOffsetModel( weaponName )\n{\n	assert( isDefined( level.stow_offset_array ) );\n\n	baseName = getBaseWeaponName( weaponName );\n	\n	return( level.stow_offset_array[baseName] );\n}\n\n\nstowPriorityWeapon()\n{\n	assert( isdefined( level.stow_priority_model_array ) );\n\n	// returns the first large projectil the player owns in case player owns more than one\n	foreach ( weapon_name, priority_weapon in level.stow_priority_model_array )\n	{\n		weaponName = getBaseWeaponName( weapon_name );\n		weaponList = self getWeaponsListAll();\n		\n		foreach ( weapon in weaponList )\n		{\n			if( self getCurrentWeapon() == weapon )\n				continue;\n			\n			if ( weaponName == getBaseWeaponName( weapon ) )\n				return weaponName + \"_mp\";\n		}\n	}\n\n	return \"\";\n}\n\n// thread loop life = player's life\nupdateStowedWeapon()\n{\n	self endon( \"spawned\" );\n	self endon( \"killed_player\" );\n	self endon( \"disconnect\" );\n\n	self.tag_stowed_back = undefined;\n	self.tag_stowed_hip = undefined;\n	\n	team = self.team;\n	class = self.class;\n	\n	self thread stowedWeaponsRefresh();\n	\n	while ( true )\n	{\n		self waittill( \"weapon_change\", newWeapon );\n		\n		if ( newWeapon == \"none\" )\n			continue;\n			\n		self thread stowedWeaponsRefresh();\n	}\n}\n\nstowedWeaponsRefresh()\n{\n	self endon( \"spawned\" );\n	self endon( \"killed_player\" );\n	self endon( \"disconnect\" );\n	\n	detach_all_weapons();\n	stow_on_back();\n	stow_on_hip();\n}\n\n\ndetach_all_weapons()\n{\n	if ( isDefined( self.tag_stowed_back ) )\n		self detach_back_weapon();\n\n	if ( isDefined( self.tag_stowed_hip ) )\n		self detach_hip_weapon();\n}\n\n\ndetach_back_weapon()\n{\n	detach_success = self detachIfAttached( self.tag_stowed_back, \"tag_stowed_back\" );\n\n	// test for bug\n	//assertex( detach_success, \"Detaching: \" + self.tag_stowed_back + \" from tag: tag_stowed_back failed.\" );\n	self.tag_stowed_back = undefined;\n}\n\n\ndetach_hip_weapon()\n{\n	detach_success = self detachIfAttached( self.tag_stowed_hip, \"tag_stowed_hip\" );\n\n	// test for bug\n	//assertex( detach_success, \"Detaching: \" + detach_model + \" from tag: tag_stowed_hip failed.\" );\n	self.tag_stowed_hip = undefined;\n}\n\n\nstow_on_back()\n{\n	prof_begin( \"stow_on_back\" );\n	currentWeapon = self getCurrentWeapon();\n	currentIsAlt = isAltModeWeapon( currentWeapon );\n\n	assert( !isDefined( self.tag_stowed_back ) );\n\n	stowWeapon = undefined;\n	stowCamo = 0;\n	large_projectile = self stowPriorityWeapon();\n	stowOffsetModel = undefined;\n\n	if ( large_projectile != \"\" )\n	{\n		stowWeapon = large_projectile;\n	}\n	else\n	{\n		weaponsList = self getWeaponsListPrimaries();\n		foreach ( weaponName in weaponsList )\n		{\n			if ( weaponName == currentWeapon )\n				continue;\n			\n			invType = weaponInventoryType( weaponName );\n			\n			if ( invType != \"primary\" )\n			{\n				if ( invType == \"altmode\" )\n					continue;\n				\n				if ( weaponClass( weaponName ) == \"pistol\" )\n					continue;\n			}\n			\n			if ( WeaponType( weaponName ) == \"riotshield\" )\n				continue;\n			\n			// Don't stow the current on our back when we're using the alt\n			if ( currentIsAlt && weaponAltWeaponName( weaponName ) == currentWeapon )\n				continue;\n				\n			stowWeapon = weaponName;\n			stowOffsetModel = getStowOffsetModel( stowWeapon );\n			\n			if ( stowWeapon == self.primaryWeapon )\n				stowCamo = self.loadoutPrimaryCamo;\n			else if ( stowWeapon == self.secondaryWeapon )\n				stowCamo = self.loadoutSecondaryCamo;\n			else\n				stowCamo = 0;\n		}		\n	}\n\n	if ( !isDefined( stowWeapon ) )\n	{\n		prof_end( \"stow_on_back\" );\n		return;\n	}\n\n	if ( large_projectile != \"\" )\n	{\n		self.tag_stowed_back = level.stow_priority_model_array[ large_projectile ];\n	}\n	else\n	{\n		self.tag_stowed_back = getWeaponModel( stowWeapon, stowCamo );	\n	}\n\n	if ( isDefined( stowOffsetModel ) )\n	{\n		self attach( stowOffsetModel, \"tag_stowed_back\", true );\n		attachTag = \"tag_stow_back_mid_attach\";\n	}\n	else\n	{\n		attachTag = \"tag_stowed_back\";\n	}\n\n	self attach( self.tag_stowed_back, attachTag, true );\n\n	hideTagList = GetWeaponHideTags( stowWeapon );\n\n	if ( !isDefined( hideTagList ) )\n	{\n		prof_end( \"stow_on_back\" );\n		return;\n	}\n\n	for ( i = 0; i < hideTagList.size; i++ )\n		self HidePart( hideTagList[ i ], self.tag_stowed_back );\n	\n	prof_end( \"stow_on_back\" );\n}\n\nstow_on_hip()\n{\n	currentWeapon = self getCurrentWeapon();\n\n	assert( !isDefined( self.tag_stowed_hip ) );\n\n	stowWeapon = undefined;\n\n	weaponsList = self getWeaponsListOffhands();\n	foreach ( weaponName in weaponsList )\n	{\n		if ( weaponName == currentWeapon )\n			continue;\n			\n		if ( weaponName != \"c4_mp\" && weaponName != \"claymore_mp\" )\n			continue;\n		\n		stowWeapon = weaponName;\n	}\n\n	if ( !isDefined( stowWeapon ) )\n		return;\n\n	self.tag_stowed_hip = getWeaponModel( stowWeapon );\n	self attach( self.tag_stowed_hip, \"tag_stowed_hip_rear\", true );\n\n	hideTagList = GetWeaponHideTags( stowWeapon );\n	\n	if ( !isDefined( hideTagList ) )\n		return;\n	\n	for ( i = 0; i < hideTagList.size; i++ )\n		self HidePart( hideTagList[ i ], self.tag_stowed_hip );\n}\n\n\nupdateSavedLastWeapon()\n{\n	self endon( \"death\" );\n	self endon( \"disconnect\" );\n\n	currentWeapon = self.currentWeaponAtSpawn;\n	self.saved_lastWeapon = currentWeapon;\n\n	for ( ;; )\n	{\n		self waittill( \"weapon_change\", newWeapon );\n	\n		if ( newWeapon == \"none\" )\n		{\n			self.saved_lastWeapon = currentWeapon;\n			continue;\n		}\n\n		weaponInvType = weaponInventoryType( newWeapon );\n\n		if ( weaponInvType != \"primary\" && weaponInvType != \"altmode\" )\n		{\n			self.saved_lastWeapon = currentWeapon;\n			continue;\n		}\n		\n		if ( newWeapon == \"onemanarmy_mp\" )\n		{\n			self.saved_lastWeapon = currentWeapon;\n			continue;\n		}\n\n		self updateMoveSpeedScale( \"primary\" );\n\n		self.saved_lastWeapon = currentWeapon;\n		currentWeapon = newWeapon;\n	}\n}\n\n\nEMPPlayer( numSeconds )\n{\n	self endon( \"disconnect\" );\n	self endon( \"death\" );\n\n	self thread clearEMPOnDeath();\n\n}\n\n\nclearEMPOnDeath()\n{\n	self endon( \"disconnect\" );\n\n	self waittill( \"death\" );\n}\n\n\nupdateMoveSpeedScale( weaponType )\n{\n	/*\n	if ( self _hasPerk( \"specialty_lightweight\" ) )\n		self.moveSpeedScaler = 1.10;\n	else\n		self.moveSpeedScaler = 1;\n	*/\n	\n	if ( !isDefined( weaponType ) || weaponType == \"primary\" || weaponType != \"secondary\" )\n		weaponType = self.primaryWeapon;\n	else\n		weaponType = self.secondaryWeapon;\n	\n	if( isDefined(self.primaryWeapon ) && self.primaryWeapon == \"riotshield_mp\" )\n	{\n		self setMoveSpeedScale( .8 * self.moveSpeedScaler );\n		return;\n	}\n	\n	if ( !isDefined( weaponType ) )\n		weapClass = \"none\";\n	else \n		weapClass = weaponClass( weaponType );\n	\n	\n	switch ( weapClass )\n	{\n		case \"rifle\":\n			self setMoveSpeedScale( 0.95 * self.moveSpeedScaler );\n			break;\n		case \"pistol\":\n			self setMoveSpeedScale( 1.0 * self.moveSpeedScaler );\n			break;\n		case \"mg\":\n			self setMoveSpeedScale( 0.875 * self.moveSpeedScaler );\n			break;\n		case \"smg\":\n			self setMoveSpeedScale( 1.0 * self.moveSpeedScaler );\n			break;\n		case \"spread\":\n			self setMoveSpeedScale( .95 * self.moveSpeedScaler );\n			break;\n		case \"rocketlauncher\":\n			self setMoveSpeedScale( 0.80 * self.moveSpeedScaler );\n			break;\n		case \"sniper\":\n			self setMoveSpeedScale( 1.0 * self.moveSpeedScaler );\n			break;\n		default:\n			self setMoveSpeedScale( 1.0 * self.moveSpeedScaler );\n			break;\n	}\n}\n\n\nbuildWeaponData( filterPerks )\n{\n	attachmentList = getAttachmentList();		\n	max_weapon_num = 149;\n\n	baseWeaponData = [];\n	\n	for( weaponId = 0; weaponId <= max_weapon_num; weaponId++ )\n	{\n		baseName = tablelookup( \"mp/statstable.csv\", 0, weaponId, 4 );\n		if( baseName == \"\" )\n			continue;\n\n		assetName = baseName + \"_mp\";\n\n		if ( !isSubStr( tableLookup( \"mp/statsTable.csv\", 0, weaponId, 2 ), \"weapon_\" ) )\n			continue;\n		\n		if ( weaponInventoryType( assetName ) != \"primary\" )\n			continue;\n\n		weaponInfo = spawnStruct();\n		weaponInfo.baseName = baseName;\n		weaponInfo.assetName = assetName;\n		weaponInfo.variants = [];\n\n		weaponInfo.variants[0] = assetName;\n		// the alphabetize function is slow so we try not to do it for every weapon/attachment combo; a code solution would be better.\n		attachmentNames = [];\n		for ( innerLoopCount = 0; innerLoopCount < 6; innerLoopCount++ )\n		{\n			// generating attachment combinations\n			attachmentName = tablelookup( \"mp/statStable.csv\", 0, weaponId, innerLoopCount + 11 );\n			\n			if ( filterPerks )\n			{\n				switch ( attachmentName )\n				{\n					case \"fmj\":\n					case \"xmags\":\n					case \"rof\":\n						continue;\n				}\n			}\n			\n			if( attachmentName == \"\" )\n				break;\n			\n			attachmentNames[attachmentName] = true;\n		}\n\n		// generate an alphabetized attachment list\n		attachments = [];\n		foreach ( attachmentName in attachmentList )\n		{\n			if ( !isDefined( attachmentNames[attachmentName] ) )\n				continue;\n			\n			weaponInfo.variants[weaponInfo.variants.size] = baseName + \"_\" + attachmentName + \"_mp\";\n			attachments[attachments.size] = attachmentName;\n		}\n\n		for ( i = 0; i < (attachments.size - 1); i++ )\n		{\n			colIndex = tableLookupRowNum( \"mp/attachmentCombos.csv\", 0, attachments[i] );\n			for ( j = i + 1; j < attachments.size; j++ )\n			{\n				if ( tableLookup( \"mp/attachmentCombos.csv\", 0, attachments[j], colIndex ) == \"no\" )\n					continue;\n					\n				weaponInfo.variants[weaponInfo.variants.size] = baseName + \"_\" + attachments[i] + \"_\" + attachments[j] + \"_mp\";\n			}\n		}\n		\n		baseWeaponData[baseName] = weaponInfo;\n	}\n	\n	return ( baseWeaponData );\n}\n\nmonitorSemtex()\n{\n	self endon( \"disconnect\" );\n	self endon( \"death\" );\n	\n	for( ;; )\n	{\n		self waittill( \"grenade_fire\", weapon );\n\n		if ( !isSubStr(weapon.model, \"semtex\" ) )\n			continue;\n			\n		weapon waittill( \"missile_stuck\", stuckTo );\n			\n		if ( !isPlayer( stuckTo ) )\n			continue;\n			\n		if ( level.teamBased && isDefined( stuckTo.team ) && stuckTo.team == self.team )\n		{\n			weapon.isStuck = \"friendly\";\n			continue;\n		}\n	\n		weapon.isStuck = \"enemy\";\n		weapon.stuckEnemyEntity = stuckTo;\n		\n		stuckTo maps\\mp\\gametypes\\_hud_message::playerCardSplashNotify( \"semtex_stuck\", self );\n		\n		self thread maps\\mp\\gametypes\\_hud_message::SplashNotify( \"stuck_semtex\", 100 );\n		self notify( \"process\", \"ch_bullseye\" );\n	}	\n}\n\n\nturret_monitorUse()\n{\n	for( ;; )\n	{\n		self waittill ( \"trigger\", player );\n		\n		self thread turret_playerThread( player );\n	}\n}\n\nturret_playerThread( player )\n{\n	player endon ( \"death\" );\n	player endon ( \"disconnect\" );\n\n	player notify ( \"weapon_change\", \"none\" );\n	\n	self waittill ( \"turret_deactivate\" );\n	\n	player notify ( \"weapon_change\", player getCurrentWeapon() );\n}\n",
			"file": "/C/Users/Justus/AppData/Local/Temp/7zO7A70.tmp/_weapons.gsc",
			"file_size": 66575,
			"file_write_time": 129281763540000000,
			"settings":
			{
				"buffer_size": 63857,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/Python/Python.sublime-build",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
			[
				"p in",
				"Package Control: Install Package"
			],
			[
				"bracketh",
				"BracketHighlighter: Toggle High Visibility Mode"
			],
			[
				"bracket",
				"BracketHighlighter: Toggle High Visibility Mode"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"package contro install",
				"Package Control: Install Package"
			],
			[
				"install package ",
				"Package Control: Install Package"
			],
			[
				"set syntax c",
				"Set Syntax: C#"
			]
		],
		"width": 464.0
	},
	"console":
	{
		"height": 125.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/C/Users/Justus/AppData/Local/Temp/7zO31DC.tmp/_menus.gsc",
		"/C/Users/Justus/AppData/Local/Temp/7zO363.tmp/_botUtil.gsc",
		"/C/Users/Justus/AppData/Local/Temp/7zODE93.tmp/_multi.gsc",
		"/C/Users/Justus/AppData/Local/Temp/7zO89BF.tmp/_OtherFunctions.gsc",
		"/C/Users/Justus/AppData/Local/Temp/7zO2DAA.tmp/_Mod.gsc",
		"/C/Users/Justus/AppData/Local/Temp/7zOA1FD.tmp/_OtherFunctions.gsc",
		"/C/Users/Justus/AppData/Local/Temp/7zOB176.tmp/_Mod.gsc",
		"/C/Users/Justus/AppData/Local/Temp/7zO8205.tmp/_rank.gsc",
		"/C/Users/Justus/AppData/Local/Temp/7zOC201.tmp/_rank.gsc",
		"/C/Users/Justus/Documents/GitHub/MW2/m2demo/Buttons.gsc",
		"/C/Users/Justus/Documents/GitHub/TTT/m2demo/startup.gsc",
		"/C/Users/Justus/Documents/GitHub/MW2/m2demo/startup.gsc",
		"/C/Users/Justus/Documents/GitHub/MW2/m2demo/customKillstreak.gsc",
		"/C/Users/Justus/Documents/GitHub/TTT/m2demo/Buttons.gsc",
		"/C/Users/Justus/Documents/GitHub/MW2/m2demo/maps/mp/gametypes/_rank.gsc",
		"/C/Users/Justus/Documents/GitHub/TTT/m2demo/TTT.gsc",
		"/C/Users/Justus/Documents/GitHub/TTT/ttt.sublime-project",
		"/C/Users/Justus/Documents/GitHub/TTT/.gitignore",
		"/C/Users/Justus/Documents/GitHub/MW2/m2demo/gungame.gsc",
		"/C/Users/Justus/Documents/GitHub/TTT/m2demo/gungame.gsc",
		"/C/Users/Justus/Documents/GitHub/TTT/m2demo/customKillstreak.gsc",
		"/C/Users/Justus/Desktop/MW2-d9a95a577e51a838fcec7e5db416cc12498faf89/MW2-d9a95a577e51a838fcec7e5db416cc12498faf89/m2demo/Buttons.gsc",
		"/C/Users/Justus/AppData/Roaming/Sublime Text 3/Packages/User/C#.sublime-settings",
		"/C/Users/Justus/AppData/Roaming/Sublime Text 2/Packages/Color Scheme - Default/custom_Espresso Libre.tmTheme",
		"/C/Users/Justus/AppData/Roaming/Sublime Text 2/Packages/Color Scheme - Default/Monokai.tmTheme",
		"/C/Users/Justus/AppData/Roaming/Sublime Text 2/Packages/User/Preferences.sublime-settings",
		"/C/Users/Justus/AppData/Roaming/Sublime Text 2/Packages/User/bh_core.sublime-settings",
		"/C/Users/Justus/AppData/Roaming/Sublime Text 2/Packages/BracketHighlighter/bh_core.sublime-settings",
		"/C/Users/Justus/AppData/Roaming/Sublime Text 2/Packages/Color Scheme - Default/Espresso Libre.tmTheme",
		"/C/Users/Justus/AppData/Roaming/Sublime Text 2/Packages/Default/Preferences.sublime-settings"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"weaponStockSize",
			"weaponClipSize",
			"newleftammo",
			"ammo",
			"bracketsForeground",
			"default",
			"\"style\": ",
			"d",
			"gudy",
			"ess you ar ver",
			"var1"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "m2demo/startup.gsc",
					"settings":
					{
						"buffer_size": 2085,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close"
							],
							"syntax": "Packages/C#/C#.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "m2demo/TTT.gsc",
					"settings":
					{
						"buffer_size": 3431,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close"
							],
							"syntax": "Packages/C#/C#.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/C/Users/Justus/AppData/Local/Temp/7zO7A70.tmp/_weapons.gsc",
					"settings":
					{
						"buffer_size": 63857,
						"regions":
						{
						},
						"selection":
						[
							[
								21327,
								21341
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close"
							],
							"syntax": "Packages/C#/C#.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 63.0,
						"translation.y": 12398.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"replace":
	{
		"height": 0.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"ssc",
				"/C/Users/Justus/Documents/GitHub/MW2/m2demo/Buttons.gsc"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
			[
				"",
				"/C/Users/Justus/Documents/GitHub/TTT/ttt.sublime-project"
			]
		],
		"width": 380.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true
}
